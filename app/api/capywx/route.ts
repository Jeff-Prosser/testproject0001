// README (quickstart)
// 1) Create a new Next.js 14+ app (App Router) and push to GitHub.
// 2) Add this file at: app/api/capywx/route.ts
// 3) On Vercel, set Environment Variables:
//    - OPENAI_API_KEY = <your OpenAI key>
//    - PIRATE_WEATHER_KEY = <your Pirate Weather key>
//    - DEFAULT_LAT = 34.181192   (optional)
//    - DEFAULT_LON = -118.326807 (optional)
// 4) Deploy. Your image endpoint will be:
//    https://<your-app>.vercel.app/api/capywx?lat=34.181192&lon=-118.326807
//    Use that URL in a DAKboard "Photo URL" block. (It returns a square PNG.)
//
// Notes:
// - We request Pirate Weather with daily data to get moonPhase + sunrise/sunset.
// - We translate weather â†’ a capybara scene prompt with SoCal urban backdrop.
// - The response is a 1024x1024 PNG generated by OpenAI (gpt-image-1).
// - Cached for 5 minutes at the edge so DAKboard updates smoothly.

// ======================== app/api/capywx/route.ts ========================
import OpenAI from "openai";
import { list, put } from "@vercel/blob";

export const runtime = "nodejs"; // more compatible with Buffer than edge
export const dynamic = "force-dynamic"; // always compute fresh-ish (cache via headers)

const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
const PIRATE_WEATHER_KEY = process.env.PIRATE_WEATHER_KEY!;
const DEFAULT_LAT = process.env.DEFAULT_LAT ?? "34.181192";
const DEFAULT_LON = process.env.DEFAULT_LON ?? "-118.326807";

if (!OPENAI_API_KEY) {
  console.warn("OPENAI_API_KEY is not set");
}
if (!PIRATE_WEATHER_KEY) {
  console.warn("PIRATE_WEATHER_KEY is not set");
}

const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

// ---------- Helpers ----------
function bucket<T>(x: number, edges: number[], labels: T[]): T {
  for (let i = 0; i < edges.length; i++) if (x < edges[i]) return labels[i];
  return labels[labels.length - 1];
}

function cacheKeyFromConditions(params: {
  lat: string; lon: string; isNight: boolean; cloud: number;
  precipType?: string; precipIntensity?: number; precipProb?: number;
  windSpeed?: number; windGust?: number; tempF?: number; moonPhase?: number; now?: number;
}): { filename: string } {
  const lat2 = Number(params.lat).toFixed(2);
  const lon2 = Number(params.lon).toFixed(2);

  const cloudB = bucket(params.cloud ?? 0, [0.1, 0.3, 0.6, 0.9], ["clr","mc","pc","mc2","ov"]);
  const pType = (params.precipType ?? "none").toLowerCase();
  const pi = params.precipIntensity ?? 0;
  const pp = params.precipProb ?? 0;
  let pBucket = "none";
  if (!(pType === "none" || (pi <= 0.01 && pp < 0.2))) {
    if (pType === "snow") pBucket = pi > 0.3 ? "snowH" : pi > 0.1 ? "snowM" : "snowL";
    else if (pType === "sleet") pBucket = "sleet";
    else pBucket = pi > 0.3 ? "rainH" : pi > 0.1 ? "rainM" : "rainL";
  }
  const ws = params.windSpeed ?? 0, wg = params.windGust ?? 0;
  const windy = ws >= 30 || wg >= 40 ? "vwind" : ws >= 20 || wg >= 30 ? "wind" : ws >= 10 ? "brz" : "calm";
  const t = params.tempF ?? 70;
  const tB = t <= 45 ? "cold" : t <= 60 ? "mild" : t >= 92 ? "hot" : "ok";
  const mB = params.isNight ? (params.moonPhase == null ? "nm" : Math.round((params.moonPhase % 1) * 8).toString()) : "day";
  const slot = params.now ? Math.floor(params.now / (30 * 60)) : 0; // roll every 30m

  const key = [params.isNight ? "n" : "d", cloudB, pBucket, windy, tB, mB, slot].join("_");
  return { filename: `capywx/${lat2}_${lon2}/${key}.png` };
}

function cloudLabel(cc?: number): string {
  const c = typeof cc === "number" ? Math.max(0, Math.min(1, cc)) : 0;
  if (c < 0.1) return "clear sky";
  if (c < 0.3) return "mostly clear sky";
  if (c < 0.6) return "partly cloudy sky";
  if (c < 0.9) return "mostly cloudy sky";
  return "overcast sky";
}

function windLabel(mph = 0, gust = 0): { text: string; cue: string } {
  if (mph >= 30 || gust >= 40) return { text: "very windy", cue: "strong wind motion" };
  if (mph >= 20 || gust >= 30) return { text: "windy", cue: "noticeable wind motion" };
  if (mph >= 10) return { text: "breezy", cue: "gentle wind" };
  return { text: "light wind", cue: "" };
}

function precipLabel(intensity = 0, prob = 0, type = "none"): string {
  // Pirate Weather intensity units (US): inches/hour; treat >0.01 as light precip
  if (type === "none" || (intensity <= 0.01 && prob < 0.2)) return "no precipitation";
  const t = type.toLowerCase();
  if (t === "snow") {
    if (intensity > 0.3) return "heavy snowfall";
    if (intensity > 0.1) return "moderate snowfall";
    return "light snowfall";
  }
  if (t === "sleet") return "sleet";
  // rain-like
  if (intensity > 0.3) return "heavy rain";
  if (intensity > 0.1) return "moderate rain";
  return "light rain or drizzle";
}

function outfitByTemp(tempF = 70): string {
  if (tempF <= 45) return "wearing a warm coat and scarf";
  if (tempF <= 60) return "wearing a light jacket";
  if (tempF >= 92) return "seeking shade and sipping a cold drink";
  return "in casual clothes";
}

function propByConditions({
  precipType,
  hasPrecip,
  windy,
  uvIndex,
  isNight,
}: {
  precipType: string;
  hasPrecip: boolean;
  windy: boolean;
  uvIndex: number;
  isNight: boolean;
}): string {
  if (hasPrecip) {
    if (precipType === "snow") return "with a cozy beanie, holding an umbrella";
    return "holding an umbrella and wearing a raincoat";
  }
  if (windy) return "holding onto a hat, scarf fluttering";
  if (!isNight && uvIndex >= 7) return "wearing sunglasses";
  return "hands free";
}

function moonLabel(phase?: number): string {
  if (phase == null) return "";
  // Dark Sky/Pirate Weather convention: 0=new, 0.25=first quarter, 0.5=full, 0.75=last quarter
  const p = phase % 1;
  if (p < 0.03 || p > 0.97) return "new moon";
  if (p < 0.22) return "waxing crescent";
  if (p < 0.28) return "first quarter";
  if (p < 0.47) return "waxing gibbous";
  if (p < 0.53) return "full moon";
  if (p < 0.72) return "waning gibbous";
  if (p < 0.78) return "last quarter";
  return "waning crescent";
}

function sceneBackdrop(isNight: boolean): string {
  // Southern California urban vibe
  return isNight
    ? "palm-lined street with warm streetlights, stucco storefronts, distant hills, subtle neon glows"
    : "sunny palm-lined boulevard, low stucco buildings, blue sky, distant hazy hills";
}

function buildPrompt({
  isNight,
  cloudText,
  precipText,
  windText,
  windCue,
  tempF,
  uvIndex,
  moonText,
  props,
}: {
  isNight: boolean;
  cloudText: string;
  precipText: string;
  windText: string;
  windCue: string;
  tempF: number;
  uvIndex: number;
  moonText: string;
  props: string;
}): string {
  const outfit = outfitByTemp(tempF);
  const describeTime = isNight ? "nighttime scene" : "daylight scene";
  const moonLine = isNight && moonText ? `, ${moonText} visible` : "";

  return [
    "A square 1:1 illustration, clean, friendly, high-contrast.",
    `A capybara ${outfit}, ${props}, in a typical urban Southern California backdrop (${sceneBackdrop(isNight)}).`,
    `Depict current weather: ${describeTime}, ${cloudText}, ${precipText}, ${windText}${moonLine}.`,
    windCue ? `Show ${windCue}.` : "",
    "Avoid any text or watermarks. Crisp edges, centered composition.",
  ]
    .filter(Boolean)
    .join(" ");
}

async function fetchPirateWeather(lat: string, lon: string) {
  const url = new URL(
    `https://api.pirateweather.net/forecast/${PIRATE_WEATHER_KEY}/${lat},${lon}`
  );
  // Need daily block for moonPhase/sunrise/sunset; exclude others for speed
  url.searchParams.set("exclude", "minutely,hourly,flags");
  url.searchParams.set("units", "us");
  url.searchParams.set("version", "2");
  url.searchParams.set("icon", "pirate");

  const res = await fetch(url.toString(), { next: { revalidate: 0 } });
  if (!res.ok) throw new Error(`Pirate Weather error: ${res.status}`);
  return (await res.json()) as any;
}

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const lat = searchParams.get("lat") ?? DEFAULT_LAT;
    const lon = searchParams.get("lon") ?? DEFAULT_LON;

    const wx = await fetchPirateWeather(lat, lon);

    const cur = wx.currently ?? {};
    const daily0 = wx.daily?.data?.[0] ?? {};

    // Day/Night: prefer sunrise/sunset if present; otherwise fallback to icon suffix
    const now = typeof cur.time === "number" ? cur.time : 0;
    const sunrise = typeof daily0.sunriseTime === "number" ? daily0.sunriseTime : undefined;
    const sunset = typeof daily0.sunsetTime === "number" ? daily0.sunsetTime : undefined;

    let isNight = false;
    if (sunrise && sunset && now) {
      isNight = now < sunrise || now > sunset;
    } else if (typeof cur.icon === "string") {
      isNight = cur.icon.endsWith("night");
    }

    const cloudText = cloudLabel(cur.cloudCover);
    const precipText = precipLabel(cur.precipIntensity, cur.precipProbability, cur.precipType);
    const wind = windLabel(cur.windSpeed, cur.windGust);

    const hasPrecip = !/no precipitation/.test(precipText);
    const props = propByConditions({
      precipType: cur.precipType ?? "none",
      hasPrecip,
      windy: /windy/.test(wind.text) || /very/.test(wind.text),
      uvIndex: cur.uvIndex ?? 0,
      isNight,
    });

    // build cache key (do this after you've read the weather fields)
    const { filename } = cacheKeyFromConditions({
      lat, lon, isNight,
      cloud: cur.cloudCover ?? 0,
      precipType: cur.precipType,
      precipIntensity: cur.precipIntensity,
      precipProb: cur.precipProbability,
      windSpeed: cur.windSpeed, windGust: cur.windGust,
      tempF: cur.temperature, moonPhase: daily0.moonPhase, now
    });

    // 1) Try cache (Vercel Blob)
    try {
      const listed = await list({ prefix: filename });
      if (listed?.blobs?.length) {
        const url = listed.blobs[0].url;
        const cached = await fetch(url);
        const body = await cached.arrayBuffer();
        return new Response(body, {
          status: 200,
          headers: {
            "Content-Type": cached.headers.get("content-type") || "image/png",
            "Cache-Control": "public, s-maxage=300, stale-while-revalidate=86400",
          },
        });
      }
    } catch { /* no blob locally? fall through to generate */ }

    const prompt = buildPrompt({
      isNight,
      cloudText,
      precipText,
      windText: wind.text,
      windCue: wind.cue,
      tempF: cur.temperature ?? 70,
      uvIndex: cur.uvIndex ?? 0,
      moonText: moonLabel(daily0.moonPhase),
      props,
    });

    const img = await openai.images.generate({ model: "gpt-image-1", prompt, size: "1024x1024" });

    const b64 = img.data?.[0]?.b64_json;
    if (!b64) throw new Error("OpenAI image generation returned no data");

    const bytes = Buffer.from(b64, "base64");

    // 2) Save to Blob for next time
    try {
      await put(filename, bytes, {
        access: "public",
        contentType: "image/png",
        addRandomSuffix: false, // keep predictable key
      });
    } catch { /* fine in local dev without token */ }

    return new Response(bytes, {
      status: 200,
      headers: {
        "Content-Type": "image/png",
        // Cache at the Vercel edge for 5 minutes, let clients reuse stale for a day
        "Cache-Control": "public, s-maxage=300, stale-while-revalidate=86400",
      },
    });
  } catch (err: any) {
    console.error(err);
    return new Response(
      `Capybara weather image error: ${err?.message ?? "unknown"}`,
      { status: 500 }
    );
  }
}

// ======================== END FILE ========================
