// README (quickstart)
// 1) Create a new Next.js 14+ app (App Router) and push to GitHub.
// 2) Add this file at: app/api/capywx/route.ts
// 3) On Vercel, set Environment Variables:
//    - OPENAI_API_KEY = <your OpenAI key>
//    - PIRATE_WEATHER_KEY = <your Pirate Weather key>
//    - DEFAULT_LAT = 34.181192   (optional)
//    - DEFAULT_LON = -118.326807 (optional)
// 4) Deploy. Your image endpoint will be:
//    https://<your-app>.vercel.app/api/capywx?lat=34.181192&lon=-118.326807
//    Use that URL in a DAKboard "Photo URL" block. (It returns a square PNG.)
//
// Notes:
// - We request Pirate Weather with daily data to get moonPhase + sunrise/sunset.
// - We translate weather â†’ a capybara scene prompt with SoCal urban backdrop.
// - The response is a 1024x1024 PNG generated by OpenAI (gpt-image-1).
// - Cached for 5 minutes at the edge so DAKboard updates smoothly.

// ======================== app/api/capywx/route.ts ========================
import OpenAI from "openai";

export const runtime = "nodejs"; // more compatible with Buffer than edge
export const dynamic = "force-dynamic"; // always compute fresh-ish (cache via headers)

const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
const PIRATE_WEATHER_KEY = process.env.PIRATE_WEATHER_KEY!;
const DEFAULT_LAT = process.env.DEFAULT_LAT ?? "34.181192";
const DEFAULT_LON = process.env.DEFAULT_LON ?? "-118.326807";

if (!OPENAI_API_KEY) {
  console.warn("OPENAI_API_KEY is not set");
}
if (!PIRATE_WEATHER_KEY) {
  console.warn("PIRATE_WEATHER_KEY is not set");
}

const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

// ---- Types for Pirate Weather ----
type PirateCurrently = {
  time?: number;
  icon?: string;
  summary?: string;
  precipIntensity?: number;
  precipProbability?: number;
  precipType?: string;
  temperature?: number;
  windSpeed?: number;
  windGust?: number;
  windBearing?: number;
  cloudCover?: number;
  uvIndex?: number;
};

type PirateDaily0 = {
  sunriseTime?: number;
  sunsetTime?: number;
  moonPhase?: number;
};

type PirateWeatherResponse = {
  currently?: PirateCurrently;
  daily?: { data?: PirateDaily0[] };
};

// ---------- Helpers ----------
function cloudLabel(cc?: number): string {
  const c = typeof cc === "number" ? Math.max(0, Math.min(1, cc)) : 0;
  if (c < 0.1) return "clear sky";
  if (c < 0.3) return "mostly clear sky";
  if (c < 0.6) return "partly cloudy sky";
  if (c < 0.9) return "mostly cloudy sky";
  return "overcast sky";
}

function windLabel(mph = 0, gust = 0): { text: string; cue: string } {
  if (mph >= 30 || gust >= 40) return { text: "very windy", cue: "strong wind motion" };
  if (mph >= 20 || gust >= 30) return { text: "windy", cue: "noticeable wind motion" };
  if (mph >= 10) return { text: "breezy", cue: "gentle wind" };
  return { text: "light wind", cue: "" };
}

function precipLabel(intensity = 0, prob = 0, type = "none"): string {
  // Pirate Weather intensity units (US): inches/hour; treat >0.01 as light precip
  if (type === "none" || (intensity <= 0.01 && prob < 0.2)) return "no precipitation";
  const t = type.toLowerCase();
  if (t === "snow") {
    if (intensity > 0.3) return "heavy snowfall";
    if (intensity > 0.1) return "moderate snowfall";
    return "light snowfall";
  }
  if (t === "sleet") return "sleet";
  // rain-like
  if (intensity > 0.3) return "heavy rain";
  if (intensity > 0.1) return "moderate rain";
  return "light rain or drizzle";
}

function outfitByTemp(tempF = 70): string {
  if (tempF <= 45) return "wearing a warm coat and scarf";
  if (tempF <= 60) return "wearing a light jacket";
  if (tempF >= 92) return "seeking shade and sipping a cold drink";
  return "in casual clothes";
}

function propByConditions({
  precipType,
  hasPrecip,
  windy,
  uvIndex,
  isNight,
}: {
  precipType: string;
  hasPrecip: boolean;
  windy: boolean;
  uvIndex: number;
  isNight: boolean;
}): string {
  if (hasPrecip) {
    if (precipType === "snow") return "with a cozy beanie, holding an umbrella";
    return "holding an umbrella and wearing a raincoat";
  }
  if (windy) return "holding onto a hat, scarf fluttering";
  if (!isNight && uvIndex >= 7) return "wearing sunglasses";
  return "hands free";
}

function moonLabel(phase?: number): string {
  if (phase == null) return "";
  // Dark Sky/Pirate Weather convention: 0=new, 0.25=first quarter, 0.5=full, 0.75=last quarter
  const p = phase % 1;
  if (p < 0.03 || p > 0.97) return "new moon";
  if (p < 0.22) return "waxing crescent";
  if (p < 0.28) return "first quarter";
  if (p < 0.47) return "waxing gibbous";
  if (p < 0.53) return "full moon";
  if (p < 0.72) return "waning gibbous";
  if (p < 0.78) return "last quarter";
  return "waning crescent";
}

function sceneBackdrop(isNight: boolean): string {
  // Southern California urban vibe
  return isNight
    ? "palm-lined street with warm streetlights, stucco storefronts, distant hills, subtle neon glows"
    : "sunny palm-lined boulevard, low stucco buildings, blue sky, distant hazy hills";
}

function buildPrompt({
  isNight,
  cloudText,
  precipText,
  windText,
  windCue,
  tempF,
  moonText,
  props,
}: {
  isNight: boolean;
  cloudText: string;
  precipText: string;
  windText: string;
  windCue: string;
  tempF: number;
  moonText: string;
  props: string;
}): string {
  const outfit = outfitByTemp(tempF);
  const describeTime = isNight ? "nighttime scene" : "daylight scene";
  const moonLine = isNight && moonText ? `, ${moonText} visible` : "";

  return [
    "A square 1:1 illustration, clean, friendly, high-contrast.",
    `A capybara ${outfit}, ${props}, in a typical urban Southern California backdrop (${sceneBackdrop(isNight)}).`,
    `Depict current weather: ${describeTime}, ${cloudText}, ${precipText}, ${windText}${moonLine}.`,
    windCue ? `Show ${windCue}.` : "",
    "Avoid any text or watermarks. Crisp edges, centered composition.",
  ]
    .filter(Boolean)
    .join(" ");
}

async function fetchPirateWeather(lat: string, lon: string) {
  const url = new URL(
    `https://api.pirateweather.net/forecast/${PIRATE_WEATHER_KEY}/${lat},${lon}`
  );
  // Need daily block for moonPhase/sunrise/sunset; exclude others for speed
  url.searchParams.set("exclude", "minutely,hourly,flags");
  url.searchParams.set("units", "us");
  url.searchParams.set("version", "2");
  url.searchParams.set("icon", "pirate");

  const res = await fetch(url.toString(), { next: { revalidate: 0 } });
  if (!res.ok) throw new Error(`Pirate Weather error: ${res.status}`);
  return (await res.json()) as PirateWeatherResponse;
}

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const lat = searchParams.get("lat") ?? DEFAULT_LAT;
    const lon = searchParams.get("lon") ?? DEFAULT_LON;

    const wx = await fetchPirateWeather(lat, lon);

    const cur = wx.currently ?? {};
    const daily0 = wx.daily?.data?.[0] ?? {};

    // Day/Night: prefer sunrise/sunset if present; otherwise fallback to icon suffix
    const now = typeof cur.time === "number" ? cur.time : 0;
    const sunrise = typeof daily0.sunriseTime === "number" ? daily0.sunriseTime : undefined;
    const sunset = typeof daily0.sunsetTime === "number" ? daily0.sunsetTime : undefined;

    let isNight = false;
    if (sunrise && sunset && now) {
      isNight = now < sunrise || now > sunset;
    } else if (typeof cur.icon === "string") {
      isNight = cur.icon.endsWith("night");
    }

    const cloudText = cloudLabel(cur.cloudCover);
    const precipText = precipLabel(cur.precipIntensity, cur.precipProbability, cur.precipType);
    const wind = windLabel(cur.windSpeed, cur.windGust);

    const hasPrecip = !/no precipitation/.test(precipText);
    const props = propByConditions({
      precipType: cur.precipType ?? "none",
      hasPrecip,
      windy: /windy/.test(wind.text) || /very/.test(wind.text),
      uvIndex: cur.uvIndex ?? 0,
      isNight,
    });

    const prompt = buildPrompt({
      isNight,
      cloudText,
      precipText,
      windText: wind.text,
      windCue: wind.cue,
      tempF: cur.temperature ?? 70,
      moonText: moonLabel(daily0.moonPhase),
      props,
    });

    const img = await openai.images.generate({
      model: "gpt-image-1",
      prompt,
      size: "1024x1024",
    });

    const b64 = img.data?.[0]?.b64_json;
    if (!b64) throw new Error("OpenAI image generation returned no data");

    const bytes = Buffer.from(b64, "base64");

    return new Response(bytes, {
      status: 200,
      headers: {
        "Content-Type": "image/png",
        // Cache at the Vercel edge for 5 minutes, let clients reuse stale for a day
        "Vercel-CDN-Cache-Control": "max-age=43200", // 12 hours at Vercel edge
        "CDN-Cache-Control": "max-age=43200",    // 12 hours for other CDNs (if any)
        "Cache-Control": "max-age=300",          // 5 minutes in the browser
      },
    });
  } catch (err: unknown) {
    console.error(err);
    const msg = err instanceof Error ? err.message : String(err);
    return new Response(`Capybara weather image error: ${msg}`, { status: 500 });
  }
}

// ======================== END FILE ========================
